// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

/*
	Package api is a generated protocol buffer package.

	It is generated from these files:
		api.proto

	It has these top-level messages:
		Request
		Response
		Assigned
		Mutation
		AssignedIds
		Operation
		Payload
		TxnContext
		Check
		Version
		LinRead
		Latency
		SchemaNode
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Request struct {
	Query   string            `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Vars    map[string]string `protobuf:"bytes,2,rep,name=vars" json:"vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StartTs uint64            `protobuf:"varint,13,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	LinRead *LinRead          `protobuf:"bytes,14,opt,name=lin_read,json=linRead" json:"lin_read,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

func (m *Request) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *Request) GetVars() map[string]string {
	if m != nil {
		return m.Vars
	}
	return nil
}

func (m *Request) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Request) GetLinRead() *LinRead {
	if m != nil {
		return m.LinRead
	}
	return nil
}

type Response struct {
	Json    []byte        `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
	Schema  []*SchemaNode `protobuf:"bytes,2,rep,name=schema" json:"schema,omitempty"`
	Txn     *TxnContext   `protobuf:"bytes,3,opt,name=txn" json:"txn,omitempty"`
	Latency *Latency      `protobuf:"bytes,12,opt,name=latency" json:"latency,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *Response) GetJson() []byte {
	if m != nil {
		return m.Json
	}
	return nil
}

func (m *Response) GetSchema() []*SchemaNode {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *Response) GetTxn() *TxnContext {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *Response) GetLatency() *Latency {
	if m != nil {
		return m.Latency
	}
	return nil
}

type Assigned struct {
	Uids    map[string]string `protobuf:"bytes,1,rep,name=uids" json:"uids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Context *TxnContext       `protobuf:"bytes,2,opt,name=context" json:"context,omitempty"`
}

func (m *Assigned) Reset()                    { *m = Assigned{} }
func (m *Assigned) String() string            { return proto.CompactTextString(m) }
func (*Assigned) ProtoMessage()               {}
func (*Assigned) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *Assigned) GetUids() map[string]string {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *Assigned) GetContext() *TxnContext {
	if m != nil {
		return m.Context
	}
	return nil
}

type Mutation struct {
	SetJson    []byte `protobuf:"bytes,1,opt,name=set_json,json=setJson,proto3" json:"set_json,omitempty"`
	DeleteJson []byte `protobuf:"bytes,2,opt,name=delete_json,json=deleteJson,proto3" json:"delete_json,omitempty"`
	SetNquads  []byte `protobuf:"bytes,3,opt,name=set_nquads,json=setNquads,proto3" json:"set_nquads,omitempty"`
	DelNquads  []byte `protobuf:"bytes,4,opt,name=del_nquads,json=delNquads,proto3" json:"del_nquads,omitempty"`
	StartTs    uint64 `protobuf:"varint,13,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitNow  bool   `protobuf:"varint,14,opt,name=commit_now,json=commitNow,proto3" json:"commit_now,omitempty"`
}

func (m *Mutation) Reset()                    { *m = Mutation{} }
func (m *Mutation) String() string            { return proto.CompactTextString(m) }
func (*Mutation) ProtoMessage()               {}
func (*Mutation) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *Mutation) GetSetJson() []byte {
	if m != nil {
		return m.SetJson
	}
	return nil
}

func (m *Mutation) GetDeleteJson() []byte {
	if m != nil {
		return m.DeleteJson
	}
	return nil
}

func (m *Mutation) GetSetNquads() []byte {
	if m != nil {
		return m.SetNquads
	}
	return nil
}

func (m *Mutation) GetDelNquads() []byte {
	if m != nil {
		return m.DelNquads
	}
	return nil
}

func (m *Mutation) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *Mutation) GetCommitNow() bool {
	if m != nil {
		return m.CommitNow
	}
	return false
}

type AssignedIds struct {
	StartId uint64 `protobuf:"varint,1,opt,name=startId,proto3" json:"startId,omitempty"`
	EndId   uint64 `protobuf:"varint,2,opt,name=endId,proto3" json:"endId,omitempty"`
}

func (m *AssignedIds) Reset()                    { *m = AssignedIds{} }
func (m *AssignedIds) String() string            { return proto.CompactTextString(m) }
func (*AssignedIds) ProtoMessage()               {}
func (*AssignedIds) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *AssignedIds) GetStartId() uint64 {
	if m != nil {
		return m.StartId
	}
	return 0
}

func (m *AssignedIds) GetEndId() uint64 {
	if m != nil {
		return m.EndId
	}
	return 0
}

type Operation struct {
	Schema   string `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	DropAttr string `protobuf:"bytes,2,opt,name=drop_attr,json=dropAttr,proto3" json:"drop_attr,omitempty"`
	DropAll  bool   `protobuf:"varint,3,opt,name=drop_all,json=dropAll,proto3" json:"drop_all,omitempty"`
	StartTs  uint64 `protobuf:"varint,4,opt,name=startTs,proto3" json:"startTs,omitempty"`
}

func (m *Operation) Reset()                    { *m = Operation{} }
func (m *Operation) String() string            { return proto.CompactTextString(m) }
func (*Operation) ProtoMessage()               {}
func (*Operation) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *Operation) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *Operation) GetDropAttr() string {
	if m != nil {
		return m.DropAttr
	}
	return ""
}

func (m *Operation) GetDropAll() bool {
	if m != nil {
		return m.DropAll
	}
	return false
}

func (m *Operation) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

// Worker services.
type Payload struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *Payload) Reset()                    { *m = Payload{} }
func (m *Payload) String() string            { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()               {}
func (*Payload) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TxnContext struct {
	StartTs  uint64   `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs uint64   `protobuf:"varint,2,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Aborted  bool     `protobuf:"varint,3,opt,name=aborted,proto3" json:"aborted,omitempty"`
	Keys     []string `protobuf:"bytes,4,rep,name=keys" json:"keys,omitempty"`
	LinRead  *LinRead `protobuf:"bytes,13,opt,name=lin_read,json=linRead" json:"lin_read,omitempty"`
}

func (m *TxnContext) Reset()                    { *m = TxnContext{} }
func (m *TxnContext) String() string            { return proto.CompactTextString(m) }
func (*TxnContext) ProtoMessage()               {}
func (*TxnContext) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *TxnContext) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *TxnContext) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *TxnContext) GetAborted() bool {
	if m != nil {
		return m.Aborted
	}
	return false
}

func (m *TxnContext) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *TxnContext) GetLinRead() *LinRead {
	if m != nil {
		return m.LinRead
	}
	return nil
}

type Check struct {
}

func (m *Check) Reset()                    { *m = Check{} }
func (m *Check) String() string            { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()               {}
func (*Check) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

type Version struct {
	Tag string `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *Version) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

type LinRead struct {
	Ids map[uint32]uint64 `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *LinRead) Reset()                    { *m = LinRead{} }
func (m *LinRead) String() string            { return proto.CompactTextString(m) }
func (*LinRead) ProtoMessage()               {}
func (*LinRead) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

func (m *LinRead) GetIds() map[uint32]uint64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

type Latency struct {
	ParsingNs    uint64 `protobuf:"varint,1,opt,name=parsing_ns,json=parsingNs,proto3" json:"parsing_ns,omitempty"`
	ProcessingNs uint64 `protobuf:"varint,2,opt,name=processing_ns,json=processingNs,proto3" json:"processing_ns,omitempty"`
	EncodingNs   uint64 `protobuf:"varint,3,opt,name=encoding_ns,json=encodingNs,proto3" json:"encoding_ns,omitempty"`
}

func (m *Latency) Reset()                    { *m = Latency{} }
func (m *Latency) String() string            { return proto.CompactTextString(m) }
func (*Latency) ProtoMessage()               {}
func (*Latency) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *Latency) GetParsingNs() uint64 {
	if m != nil {
		return m.ParsingNs
	}
	return 0
}

func (m *Latency) GetProcessingNs() uint64 {
	if m != nil {
		return m.ProcessingNs
	}
	return 0
}

func (m *Latency) GetEncodingNs() uint64 {
	if m != nil {
		return m.EncodingNs
	}
	return 0
}

type SchemaNode struct {
	Predicate string   `protobuf:"bytes,1,opt,name=predicate,proto3" json:"predicate,omitempty"`
	Type      string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Index     bool     `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	Tokenizer []string `protobuf:"bytes,4,rep,name=tokenizer" json:"tokenizer,omitempty"`
	Reverse   bool     `protobuf:"varint,5,opt,name=reverse,proto3" json:"reverse,omitempty"`
	Count     bool     `protobuf:"varint,6,opt,name=count,proto3" json:"count,omitempty"`
	List      bool     `protobuf:"varint,7,opt,name=list,proto3" json:"list,omitempty"`
}

func (m *SchemaNode) Reset()                    { *m = SchemaNode{} }
func (m *SchemaNode) String() string            { return proto.CompactTextString(m) }
func (*SchemaNode) ProtoMessage()               {}
func (*SchemaNode) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func (m *SchemaNode) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *SchemaNode) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SchemaNode) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

func (m *SchemaNode) GetTokenizer() []string {
	if m != nil {
		return m.Tokenizer
	}
	return nil
}

func (m *SchemaNode) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *SchemaNode) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

func (m *SchemaNode) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

func init() {
	proto.RegisterType((*Request)(nil), "api.Request")
	proto.RegisterType((*Response)(nil), "api.Response")
	proto.RegisterType((*Assigned)(nil), "api.Assigned")
	proto.RegisterType((*Mutation)(nil), "api.Mutation")
	proto.RegisterType((*AssignedIds)(nil), "api.AssignedIds")
	proto.RegisterType((*Operation)(nil), "api.Operation")
	proto.RegisterType((*Payload)(nil), "api.Payload")
	proto.RegisterType((*TxnContext)(nil), "api.TxnContext")
	proto.RegisterType((*Check)(nil), "api.Check")
	proto.RegisterType((*Version)(nil), "api.Version")
	proto.RegisterType((*LinRead)(nil), "api.LinRead")
	proto.RegisterType((*Latency)(nil), "api.Latency")
	proto.RegisterType((*SchemaNode)(nil), "api.SchemaNode")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Dgraph service

type DgraphClient interface {
	Query(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	Mutate(ctx context.Context, in *Mutation, opts ...grpc.CallOption) (*Assigned, error)
	Alter(ctx context.Context, in *Operation, opts ...grpc.CallOption) (*Payload, error)
	CommitOrAbort(ctx context.Context, in *TxnContext, opts ...grpc.CallOption) (*TxnContext, error)
	CheckVersion(ctx context.Context, in *Check, opts ...grpc.CallOption) (*Version, error)
}

type dgraphClient struct {
	cc *grpc.ClientConn
}

func NewDgraphClient(cc *grpc.ClientConn) DgraphClient {
	return &dgraphClient{cc}
}

func (c *dgraphClient) Query(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/api.Dgraph/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dgraphClient) Mutate(ctx context.Context, in *Mutation, opts ...grpc.CallOption) (*Assigned, error) {
	out := new(Assigned)
	err := grpc.Invoke(ctx, "/api.Dgraph/Mutate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dgraphClient) Alter(ctx context.Context, in *Operation, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := grpc.Invoke(ctx, "/api.Dgraph/Alter", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dgraphClient) CommitOrAbort(ctx context.Context, in *TxnContext, opts ...grpc.CallOption) (*TxnContext, error) {
	out := new(TxnContext)
	err := grpc.Invoke(ctx, "/api.Dgraph/CommitOrAbort", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dgraphClient) CheckVersion(ctx context.Context, in *Check, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := grpc.Invoke(ctx, "/api.Dgraph/CheckVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Dgraph service

type DgraphServer interface {
	Query(context.Context, *Request) (*Response, error)
	Mutate(context.Context, *Mutation) (*Assigned, error)
	Alter(context.Context, *Operation) (*Payload, error)
	CommitOrAbort(context.Context, *TxnContext) (*TxnContext, error)
	CheckVersion(context.Context, *Check) (*Version, error)
}

func RegisterDgraphServer(s *grpc.Server, srv DgraphServer) {
	s.RegisterService(&_Dgraph_serviceDesc, srv)
}

func _Dgraph_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DgraphServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Dgraph/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DgraphServer).Query(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dgraph_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Mutation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DgraphServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Dgraph/Mutate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DgraphServer).Mutate(ctx, req.(*Mutation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dgraph_Alter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Operation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DgraphServer).Alter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Dgraph/Alter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DgraphServer).Alter(ctx, req.(*Operation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dgraph_CommitOrAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxnContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DgraphServer).CommitOrAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Dgraph/CommitOrAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DgraphServer).CommitOrAbort(ctx, req.(*TxnContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dgraph_CheckVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Check)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DgraphServer).CheckVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Dgraph/CheckVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DgraphServer).CheckVersion(ctx, req.(*Check))
	}
	return interceptor(ctx, in, info, handler)
}

var _Dgraph_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Dgraph",
	HandlerType: (*DgraphServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _Dgraph_Query_Handler,
		},
		{
			MethodName: "Mutate",
			Handler:    _Dgraph_Mutate_Handler,
		},
		{
			MethodName: "Alter",
			Handler:    _Dgraph_Alter_Handler,
		},
		{
			MethodName: "CommitOrAbort",
			Handler:    _Dgraph_CommitOrAbort_Handler,
		},
		{
			MethodName: "CheckVersion",
			Handler:    _Dgraph_CheckVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	if len(m.Vars) > 0 {
		for k, _ := range m.Vars {
			dAtA[i] = 0x12
			i++
			v := m.Vars[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartTs))
	}
	if m.LinRead != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LinRead.Size()))
		n1, err := m.LinRead.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Json)))
		i += copy(dAtA[i:], m.Json)
	}
	if len(m.Schema) > 0 {
		for _, msg := range m.Schema {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Txn != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Txn.Size()))
		n2, err := m.Txn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Latency != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Latency.Size()))
		n3, err := m.Latency.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Assigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Assigned) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		for k, _ := range m.Uids {
			dAtA[i] = 0xa
			i++
			v := m.Uids[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Context != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Context.Size()))
		n4, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *Mutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SetJson) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetJson)))
		i += copy(dAtA[i:], m.SetJson)
	}
	if len(m.DeleteJson) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DeleteJson)))
		i += copy(dAtA[i:], m.DeleteJson)
	}
	if len(m.SetNquads) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SetNquads)))
		i += copy(dAtA[i:], m.SetNquads)
	}
	if len(m.DelNquads) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DelNquads)))
		i += copy(dAtA[i:], m.DelNquads)
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartTs))
	}
	if m.CommitNow {
		dAtA[i] = 0x70
		i++
		if m.CommitNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AssignedIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignedIds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartId))
	}
	if m.EndId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.EndId))
	}
	return i, nil
}

func (m *Operation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	if len(m.DropAttr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DropAttr)))
		i += copy(dAtA[i:], m.DropAttr)
	}
	if m.DropAll {
		dAtA[i] = 0x18
		i++
		if m.DropAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartTs))
	}
	return i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *TxnContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CommitTs))
	}
	if m.Aborted {
		dAtA[i] = 0x18
		i++
		if m.Aborted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LinRead != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LinRead.Size()))
		n5, err := m.LinRead.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Check) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Check) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	return i, nil
}

func (m *LinRead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinRead) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for k, _ := range m.Ids {
			dAtA[i] = 0xa
			i++
			v := m.Ids[k]
			mapSize := 1 + sovApi(uint64(k)) + 1 + sovApi(uint64(v))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintApi(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Latency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Latency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ParsingNs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ParsingNs))
	}
	if m.ProcessingNs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ProcessingNs))
	}
	if m.EncodingNs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.EncodingNs))
	}
	return i, nil
}

func (m *SchemaNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Predicate) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Predicate)))
		i += copy(dAtA[i:], m.Predicate)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Index {
		dAtA[i] = 0x18
		i++
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Reverse {
		dAtA[i] = 0x28
		i++
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Count {
		dAtA[i] = 0x30
		i++
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.List {
		dAtA[i] = 0x38
		i++
		if m.List {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64Api(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Api(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Request) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Vars) > 0 {
		for k, v := range m.Vars {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.StartTs != 0 {
		n += 1 + sovApi(uint64(m.StartTs))
	}
	if m.LinRead != nil {
		l = m.LinRead.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Latency != nil {
		l = m.Latency.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Assigned) Size() (n int) {
	var l int
	_ = l
	if len(m.Uids) > 0 {
		for k, v := range m.Uids {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Mutation) Size() (n int) {
	var l int
	_ = l
	l = len(m.SetJson)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DeleteJson)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SetNquads)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DelNquads)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovApi(uint64(m.StartTs))
	}
	if m.CommitNow {
		n += 2
	}
	return n
}

func (m *AssignedIds) Size() (n int) {
	var l int
	_ = l
	if m.StartId != 0 {
		n += 1 + sovApi(uint64(m.StartId))
	}
	if m.EndId != 0 {
		n += 1 + sovApi(uint64(m.EndId))
	}
	return n
}

func (m *Operation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DropAttr)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DropAll {
		n += 2
	}
	if m.StartTs != 0 {
		n += 1 + sovApi(uint64(m.StartTs))
	}
	return n
}

func (m *Payload) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TxnContext) Size() (n int) {
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovApi(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovApi(uint64(m.CommitTs))
	}
	if m.Aborted {
		n += 2
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.LinRead != nil {
		l = m.LinRead.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Check) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Version) Size() (n int) {
	var l int
	_ = l
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *LinRead) Size() (n int) {
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for k, v := range m.Ids {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Latency) Size() (n int) {
	var l int
	_ = l
	if m.ParsingNs != 0 {
		n += 1 + sovApi(uint64(m.ParsingNs))
	}
	if m.ProcessingNs != 0 {
		n += 1 + sovApi(uint64(m.ProcessingNs))
	}
	if m.EncodingNs != 0 {
		n += 1 + sovApi(uint64(m.EncodingNs))
	}
	return n
}

func (m *SchemaNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Predicate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Index {
		n += 2
	}
	if len(m.Tokenizer) > 0 {
		for _, s := range m.Tokenizer {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Reverse {
		n += 2
	}
	if m.Count {
		n += 2
	}
	if m.List {
		n += 2
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vars == nil {
				m.Vars = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Vars[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinRead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinRead == nil {
				m.LinRead = &LinRead{}
			}
			if err := m.LinRead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = append(m.Json[:0], dAtA[iNdEx:postIndex]...)
			if m.Json == nil {
				m.Json = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, &SchemaNode{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &TxnContext{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latency == nil {
				m.Latency = &Latency{}
			}
			if err := m.Latency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uids == nil {
				m.Uids = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uids[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &TxnContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetJson = append(m.SetJson[:0], dAtA[iNdEx:postIndex]...)
			if m.SetJson == nil {
				m.SetJson = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteJson = append(m.DeleteJson[:0], dAtA[iNdEx:postIndex]...)
			if m.DeleteJson == nil {
				m.DeleteJson = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetNquads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetNquads = append(m.SetNquads[:0], dAtA[iNdEx:postIndex]...)
			if m.SetNquads == nil {
				m.SetNquads = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelNquads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelNquads = append(m.DelNquads[:0], dAtA[iNdEx:postIndex]...)
			if m.DelNquads == nil {
				m.DelNquads = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommitNow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignedIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignedIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignedIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartId", wireType)
			}
			m.StartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndId", wireType)
			}
			m.EndId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropAll = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aborted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aborted = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinRead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinRead == nil {
				m.LinRead = &LinRead{}
			}
			if err := m.LinRead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinRead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinRead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinRead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ids == nil {
				m.Ids = make(map[uint32]uint64)
			}
			var mapkey uint32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ids[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Latency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Latency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Latency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParsingNs", wireType)
			}
			m.ParsingNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParsingNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessingNs", wireType)
			}
			m.ProcessingNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessingNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingNs", wireType)
			}
			m.EncodingNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenizer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokenizer = append(m.Tokenizer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.List = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 903 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xd1, 0x6e, 0x1b, 0x45,
	0x17, 0xf6, 0xc6, 0x4e, 0x76, 0xf7, 0xd8, 0xee, 0x5f, 0x8d, 0x7e, 0xca, 0xe2, 0x90, 0x10, 0x16,
	0xa9, 0x31, 0x45, 0xf2, 0x45, 0x2a, 0x01, 0x42, 0xe2, 0x22, 0x4d, 0xb9, 0x30, 0x02, 0xb7, 0x2c,
	0xa1, 0xb7, 0xd6, 0xd4, 0x73, 0xe4, 0x6c, 0xb3, 0x99, 0xdd, 0xcc, 0x8c, 0xd3, 0x98, 0xc7, 0xe0,
	0x0a, 0x89, 0xf7, 0xe0, 0x92, 0xeb, 0x5e, 0xf2, 0x08, 0x28, 0xf0, 0x20, 0x68, 0xce, 0xcc, 0xd8,
	0x4e, 0x15, 0x55, 0xe2, 0x6e, 0xce, 0xf7, 0x9d, 0x39, 0x7b, 0xce, 0x37, 0xdf, 0xcc, 0x42, 0xca,
	0x9b, 0x72, 0xd4, 0xa8, 0xda, 0xd4, 0xac, 0xcd, 0x9b, 0x32, 0x7f, 0x13, 0x41, 0x5c, 0xe0, 0xe5,
	0x02, 0xb5, 0x61, 0xff, 0x87, 0xed, 0xcb, 0x05, 0xaa, 0x65, 0x16, 0x1d, 0x44, 0xc3, 0xb4, 0x70,
	0x01, 0x7b, 0x04, 0x9d, 0x2b, 0xae, 0x74, 0xb6, 0x75, 0xd0, 0x1e, 0x76, 0x8f, 0x1e, 0x8c, 0x6c,
	0x01, 0xbf, 0x63, 0xf4, 0x82, 0x2b, 0xfd, 0x8d, 0x34, 0x6a, 0x59, 0x50, 0x0e, 0xfb, 0x00, 0x12,
	0x6d, 0xb8, 0x32, 0x53, 0xa3, 0xb3, 0xfe, 0x41, 0x34, 0xec, 0x14, 0x31, 0xc5, 0xa7, 0x9a, 0x1d,
	0x42, 0x52, 0x95, 0x72, 0xaa, 0x90, 0x8b, 0xec, 0xde, 0x41, 0x34, 0xec, 0x1e, 0xf5, 0xa8, 0xd4,
	0x77, 0xa5, 0x2c, 0x90, 0x8b, 0x22, 0xae, 0xdc, 0x62, 0xf0, 0x05, 0xa4, 0xab, 0xb2, 0xec, 0x3e,
	0xb4, 0xcf, 0x31, 0x34, 0x64, 0x97, 0xb6, 0xc9, 0x2b, 0x5e, 0x2d, 0x30, 0xdb, 0x72, 0x4d, 0x52,
	0xf0, 0xd5, 0xd6, 0x97, 0x51, 0xfe, 0x4b, 0x04, 0x49, 0x81, 0xba, 0xa9, 0xa5, 0x46, 0xc6, 0xa0,
	0xf3, 0x4a, 0xd7, 0x92, 0x76, 0xf6, 0x0a, 0x5a, 0xb3, 0x43, 0xd8, 0xd1, 0xb3, 0x33, 0xbc, 0xe0,
	0x7e, 0x96, 0xff, 0x51, 0x03, 0x3f, 0x12, 0x34, 0xa9, 0x05, 0x16, 0x9e, 0x66, 0x1f, 0x43, 0xdb,
	0x5c, 0xcb, 0xac, 0x4d, 0x6d, 0xba, 0xac, 0xd3, 0x6b, 0x79, 0x52, 0x4b, 0x83, 0xd7, 0xa6, 0xb0,
	0x1c, 0x7b, 0x08, 0x71, 0xc5, 0x0d, 0xca, 0xd9, 0x32, 0xeb, 0x6d, 0x4e, 0xe3, 0xb0, 0x22, 0x90,
	0xf9, 0x6f, 0x11, 0x24, 0xc7, 0x5a, 0x97, 0x73, 0x89, 0x82, 0x7d, 0x06, 0x9d, 0x45, 0x29, 0x74,
	0x16, 0xd1, 0xe7, 0xdf, 0xa7, 0x1d, 0x81, 0x1c, 0xfd, 0x54, 0x8a, 0xa0, 0xa5, 0x4d, 0x62, 0x9f,
	0x42, 0x3c, 0x73, 0x5f, 0xa4, 0x51, 0xef, 0x68, 0x24, 0xf0, 0x56, 0xb2, 0xd5, 0xee, 0xff, 0x24,
	0xd9, 0x1f, 0x11, 0x24, 0xdf, 0x2f, 0x0c, 0x37, 0x65, 0x2d, 0xe9, 0xf0, 0xd0, 0x4c, 0x37, 0x64,
	0x8b, 0x35, 0x9a, 0x6f, 0xad, 0x72, 0x1f, 0x41, 0x57, 0x60, 0x85, 0x06, 0x1d, 0xbb, 0x45, 0x2c,
	0x38, 0x88, 0x12, 0xf6, 0x00, 0xec, 0x5e, 0x79, 0xb9, 0xe0, 0x42, 0x93, 0x70, 0xbd, 0x22, 0xd5,
	0x68, 0x26, 0x04, 0x58, 0x5a, 0x60, 0x15, 0xe8, 0x8e, 0xa3, 0x05, 0x56, 0x9e, 0x7e, 0x87, 0x6d,
	0xf6, 0x00, 0x66, 0xf5, 0xc5, 0x45, 0x69, 0xa6, 0xb2, 0x7e, 0x4d, 0xc6, 0x49, 0x8a, 0xd4, 0x21,
	0x93, 0xfa, 0x75, 0xfe, 0x35, 0x74, 0x83, 0x80, 0x63, 0xa1, 0x59, 0x06, 0x6e, 0xe3, 0x58, 0xd0,
	0x04, 0xa1, 0xce, 0x58, 0x58, 0x0d, 0x50, 0x8a, 0xb1, 0xa0, 0xde, 0x3b, 0x85, 0x0b, 0xf2, 0x05,
	0xa4, 0xcf, 0x1a, 0x54, 0x6e, 0xfe, 0x07, 0x2b, 0x7b, 0x38, 0xed, 0x82, 0x1b, 0x76, 0x21, 0x15,
	0xaa, 0x6e, 0xa6, 0xdc, 0x18, 0xe5, 0x25, 0x4c, 0x2c, 0x70, 0x6c, 0x8c, 0xb2, 0xad, 0x3b, 0xb2,
	0xaa, 0x68, 0xec, 0xa4, 0x88, 0x89, 0xab, 0xaa, 0x55, 0x33, 0xa7, 0x6e, 0xe2, 0xf5, 0x50, 0xf9,
	0x1e, 0xc4, 0xcf, 0xf9, 0xb2, 0xaa, 0xb9, 0xb0, 0x3e, 0x7d, 0xca, 0x0d, 0x0f, 0x3e, 0xb5, 0x6b,
	0xeb, 0x19, 0x58, 0x1f, 0xf3, 0x2d, 0x75, 0xa2, 0xdb, 0xea, 0xec, 0x82, 0xd7, 0xc2, 0x72, 0x6e,
	0xb2, 0xc4, 0x01, 0xa7, 0x24, 0x06, 0x7f, 0x59, 0x2b, 0x83, 0x22, 0x74, 0xe6, 0x43, 0xfb, 0xd1,
	0x73, 0x5c, 0xda, 0xb6, 0xda, 0xc3, 0xb4, 0xa0, 0xf5, 0xad, 0xfb, 0xd9, 0x7f, 0xc7, 0xfd, 0xcc,
	0x63, 0xd8, 0x3e, 0x39, 0xc3, 0xd9, 0x79, 0xbe, 0x0b, 0xf1, 0x0b, 0x54, 0xda, 0x4a, 0x77, 0x1f,
	0xda, 0x86, 0xcf, 0x83, 0xe7, 0x0c, 0x9f, 0xe7, 0xaf, 0x20, 0xf6, 0x3b, 0xd9, 0x21, 0xb4, 0xd7,
	0xa6, 0x7f, 0x6f, 0xb3, 0xe8, 0x68, 0x1c, 0x2c, 0x6f, 0x33, 0x06, 0x9f, 0x43, 0x32, 0xbe, 0xc3,
	0xc5, 0xfd, 0x3b, 0x5c, 0xdc, 0xd9, 0x74, 0xb1, 0x84, 0xd8, 0xdf, 0x3b, 0x6b, 0x97, 0x86, 0x2b,
	0x5d, 0xca, 0xf9, 0x54, 0x06, 0xb5, 0x52, 0x8f, 0x4c, 0x34, 0xfb, 0x04, 0xfa, 0x8d, 0xaa, 0x67,
	0xa8, 0x43, 0x86, 0xab, 0xd5, 0x5b, 0x83, 0x13, 0x6d, 0xcd, 0x8e, 0x72, 0x56, 0x0b, 0x9f, 0xd2,
	0xa6, 0x14, 0x08, 0xd0, 0x44, 0xe7, 0xbf, 0x47, 0x00, 0xeb, 0x57, 0x83, 0x7d, 0x08, 0x69, 0xa3,
	0x50, 0x94, 0x33, 0x6e, 0xd0, 0x4b, 0xb0, 0x06, 0xac, 0xd6, 0x66, 0xd9, 0x84, 0xbb, 0x47, 0x6b,
	0x3b, 0x4a, 0x29, 0x05, 0x5e, 0xfb, 0x73, 0x71, 0x81, 0xad, 0x63, 0xea, 0x73, 0x94, 0xe5, 0xcf,
	0xa8, 0xfc, 0xd1, 0xac, 0x01, 0x7b, 0x9a, 0x0a, 0xaf, 0x50, 0x69, 0xcc, 0xb6, 0xdd, 0x69, 0xfa,
	0xd0, 0x56, 0x9b, 0xd5, 0x0b, 0x69, 0xb2, 0x1d, 0x57, 0x8d, 0x02, 0xfb, 0xdd, 0xaa, 0xd4, 0x26,
	0x8b, 0x09, 0xa4, 0xf5, 0xd1, 0x3f, 0x11, 0xec, 0x3c, 0x9d, 0x2b, 0xde, 0x9c, 0xb1, 0x87, 0xb0,
	0xfd, 0x03, 0x3d, 0xef, 0xbd, 0xcd, 0x07, 0x7d, 0xd0, 0xf7, 0x91, 0x7b, 0x45, 0xf3, 0x16, 0x1b,
	0xc2, 0x0e, 0x3d, 0x10, 0xc8, 0x1c, 0x15, 0x5e, 0x0b, 0x9f, 0x19, 0x2e, 0x5f, 0xde, 0x62, 0x87,
	0xb0, 0x7d, 0x5c, 0x19, 0x54, 0xec, 0x1e, 0x31, 0xab, 0x7b, 0x35, 0x70, 0x5f, 0xf0, 0x86, 0xcf,
	0x5b, 0xec, 0x31, 0xf4, 0x4f, 0xc8, 0xa3, 0xcf, 0xd4, 0xb1, 0x35, 0x24, 0x7b, 0xfb, 0x61, 0x1b,
	0xbc, 0x0d, 0xe4, 0x2d, 0xf6, 0x08, 0x7a, 0xe4, 0xba, 0xe0, 0x38, 0xa0, 0x14, 0x82, 0xfc, 0x07,
	0x3c, 0x93, 0xb7, 0x9e, 0x0c, 0xdf, 0xdc, 0xec, 0x47, 0x7f, 0xde, 0xec, 0x47, 0x7f, 0xdd, 0xec,
	0x47, 0xbf, 0xfe, 0xbd, 0xdf, 0x82, 0xb4, 0xac, 0x47, 0x82, 0x06, 0x7f, 0xd2, 0x75, 0x02, 0x3c,
	0xb7, 0xbf, 0xc0, 0x97, 0x3b, 0xf4, 0x27, 0x7c, 0xfc, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x29,
	0x6b, 0xa0, 0xa9, 0x16, 0x07, 0x00, 0x00,
}
